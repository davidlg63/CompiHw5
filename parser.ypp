%{
#include <iostream>
#include "hw3_output.hpp"
#include "SymbolTableManager.h"
#include "CodeGenerator.h"


int yylex();
void yyerror (const char*);
extern int yylineno;

SymbolTableManager symbolTableManager = SymbolTableManager();
CodeBuffer& codeBuff = CodeBuffer::instance();

void CheckType( Type_ target, Type_ given);
void checkIfVarExists(Type_ type, const std::string& name);
void MakeDeclaration(Type_ type, const std::string& name);
void checkIfFuncExist(const std::string& name, std::vector<Type_> params);
void CheckIfAssignmentValid(const std::string& name, Type_ type2);
void checkIfNumType(Type_ type);
void InsertPrintFunctions();
void checkIfDoubleDeclare(const std::string& name, std::vector<std::string>names_in_list);
bool isRetTypeMismatch(Type_ expType);
void checkIfMainRedefined(const std::string& functionName);
void CheckIfValidTypeForVar(const Type_ type_to_assign);
void debug();

using namespace std;
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%left OR
%left AND
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%right IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc COMMA
%nonassoc SC
%nonassoc ID
%right ASSIGN
%left RELOP_EQ
%left RELOP_NOTEQ
%left RELOP_LESS
%left RELOP_GREATER
%left RELOP_LEQ
%left RELOP_GEQ
%left BINOP_PLUS
%left BINOP_MINUS
%left BINOP_MUL
%left BINOP_DIV
%right NOT
%nonassoc NUM
%nonassoc STRING
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%right ELSE
%%
    Program: {symbolTableManager.openScope(); InsertPrintFunctions();} Funcs	                                            {
																																
																																if(Type_::TYPE_VOID != symbolTableManager.doesFunctionExist("main", vector<Type_>())) 
																																	{output::errorMainMissing(); exit(1);}
																																symbolTableManager.closeScope();
																															}
            ;

    Funcs:                   	                                {}
			| FuncDecl Funcs	                                {}
	        ;


    FuncDecl: {symbolTableManager.openFuncScope();} FuncDeclaration FuncBody CLOSE_SCOPE	{};
	
	FuncDeclaration: retType ID LPAREN Formals RPAREN 												{
																										checkIfMainRedefined(dynamic_cast<Id*>($2)->name);
																										checkIfDoubleDeclare(dynamic_cast<Id*>($2)->name, 
																										dynamic_cast<paramList*>($4)->names_in_list);
																								
																										symbolTableManager.top()->InsertFunction(dynamic_cast<Id*>($2)->name,
																										dynamic_cast<retType*>($1)->type, 0, 
																										dynamic_cast<paramList*>($4)->types_in_list, dynamic_cast<paramList*>($4)->names_in_list);
																										
																										$$ = new call2Fun();
																										dynamic_cast<call2Fun*>($$)->name = dynamic_cast<Id*>($2)->name;
																										dynamic_cast<call2Fun*>($$)->retType = dynamic_cast<retType*>($1)->type;
																										dynamic_cast<call2Fun*>($$)->expList = dynamic_cast<paramList*>($4)->types_in_list;
																										
																										string sType = symbolTableManager.ConvertTypeToString(dynamic_cast<call2Fun*>($$)->retType);
																										int paramsListSize = dynamic_cast<call2Fun*>($$)->expList->names_in_list.size();
																										string sParams = "(";
																										for (inti i=0; i<paramsListSize; i++)
																										{
																											sParams += "i32, ";
																										}
																										sParams += ")";
																										string code = "define" + sType + "@" + dynamic_cast<call2Fun*>($$)->name + sParams;
																										for (int i=0; i<paramsListSize; i++)
																										{
																											string reg = RegisterGenerator::getRegister();
																											symbolTableManager.assignRegisterToVar(dynamic_cast<call2Fun*>($$)->expList[i], reg);
																											string allocationCommand = reg + " = aloca i32";
																											codeBuff.emit(allocationCommand);
																										}
																										for (int i=0; i<paramsListSize; i++)
																										{
																											string storeCommand - "store i32 %" + itoa(i) + " ,i32* " + symbolTableManager.getVarRegister(dynamic_cast<call2Fun*>($$)->expList[i]);
																											codeBuff.emit(storeCommand);
																										}
																										string stackVar = RegisterGenerator::getRegister() + "sp";
																										string stackPointer = symbolTableManager.getStackPointer();
																										stackPointer = stackVar;
																										code = stackVar + " = alloca [50 x i32]";
																										CodeBuffer::instance().emit(code);
																										
																										
																										delete dynamic_cast<retType*>($1); delete dynamic_cast<Id*>($2); 
																										delete dynamic_cast<paramList*>($4);
																									};
	FuncBody: LBRACE Statements RBRACE 																{};


    retType: /*epsilon*/										{output::errorSyn(yylineno);exit(1);} |
			 Type	                                            {$$ = new retType(); dynamic_cast<retType*>($$)->type = dynamic_cast<retType*>($1)->type; delete dynamic_cast<retType*>($1);} |
			 VOID	                                            {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_VOID;}
			 ;


    Formals: /*epsilon*/	                                    {$$ = new paramList();} |
             FormalsList	                                    {$$ = new paramList();
                                                                dynamic_cast<paramList*>($$)-> names_in_list = dynamic_cast<paramList*>($1)->names_in_list;
                                                                dynamic_cast<paramList*>($$) -> types_in_list = dynamic_cast<paramList*>($1) -> types_in_list;
                                                                delete dynamic_cast<retType*>($1);}
			 ;														

    FormalsList: FormalDecl	                                     {
																	$$ = new paramList();
																	dynamic_cast<paramList*>($$)->names_in_list = std::vector<std::string>(1, dynamic_cast<Param*>($1)->name);
																	dynamic_cast<paramList*>($$) -> types_in_list = std::vector<Type_>(1, dynamic_cast<Param*>($1)->type);
																	delete dynamic_cast<retType*>($1);
																 } |
				FormalDecl COMMA FormalsList                     {$$ = new paramList();
																 paramList* formals_list = dynamic_cast<paramList*>($$);
																 Param* formal_decl = dynamic_cast<Param*>($1);
																 paramList* formal_decl_list = dynamic_cast<paramList*>($3);
				                                                 formals_list-> names_in_list = formal_decl_list->names_in_list;
				                                                 formals_list-> types_in_list = formal_decl_list-> types_in_list;
																 formals_list->names_in_list.insert(formals_list->names_in_list.begin(), formal_decl->name);
																 formals_list->types_in_list.insert(formals_list->types_in_list.begin(), formal_decl->type);
				                                                 delete formal_decl;
																 delete formal_decl_list;
																 }
				;


    FormalDecl: Type ID	                            			{
																	checkIfVarExists(dynamic_cast<retType*>($1) -> type, dynamic_cast<Id*>($2) -> name);
																	$$ = new Param(dynamic_cast<retType*>($1) -> type, dynamic_cast<Id*>($2)->name);
																	delete dynamic_cast<retType*>($1);  
																	delete dynamic_cast<Id*>($2); 
																}

	;


    Statements: Statement	                                    {
																	$$ = new Statement();
																	Statement* statement = dynamic_cast<Statement*>($1);
																	$$->nextList = statement->nextList;
																	$$->breakList = statement->breakList;
																	$$->continueList = statement->continueList;
																	delete statement;
																} |
				Statements M_INSTR  Statement	                { //BUG: maybe here
																	$$ = new Statement();
																	Statement* last = dynamic_cast<Statement*>($3);
																	Statement* rest = dynamic_cast<Statement*>($1);
																	codeBuff.bpatch(rest->nextList, dynamic_cast<Label*>($2)->label);
																	$$->nextList = last->nextList;
																	$$->breakList = codeBuff.merge(rest->breakList, last->breakList);
																	$$->continueList = codeBuff.merge(rest->continueList, last->continueList);
																	delete last;
																	delete rest;
																}
				;


	Statement:
				LBRACE {symbolTableManager.openScope();} Statements RBRACE	{
																				$$ = new Statement();
																				Statement* inner = dynamic_cast<Statement*>($3);
																				$$->nextList = inner->nextList;
																				$$->breakList = inner->breakList;
																				$$->continueList = inner->continueList;
																				symbolTableManager.closeScope();
																				delete inner;
																			} |
				
				Type ID SC	                                    {
																	MakeDeclaration(dynamic_cast<retType*>($1)->type, dynamic_cast<Id*>($2)->name);
																	
																	$$ = new Statement();
																	int offset = symbolTableManager.getVarOffset(dynamic_cast<Id*>($2)->name);
																	if(offset >= 0)
																	{
																		string reg = RegisterGenerator::getRegister()
																		string regPtr = "%t"+ reg;
																		string code = regPtr + " = getelementptr [50 x i32], [50 x i32]* " + symbolTableManager.getStackPointer + ", i32 0 , i32 " + stoi(offset);
																		CodeBuffer::instance().emit(code);
																		symbolTableManager.assignRegisterToVar(dynamic_cast<Id*>($2)->name, reg);
																		code = "store i32 0, i32* " + regPtr;
																		CodeBuffer::instance().emit(code);
																	}
																	
																	delete dynamic_cast<Id*>($2);
																	delete dynamic_cast<retType*>($1); delete dynamic_cast<Id*>($2);
																} |
																
				Type ID ASSIGN Exp SC	                        { 
																	CheckType(dynamic_cast<retType*>($1)->type, dynamic_cast<retType*>($4)->type);
																	MakeDeclaration(dynamic_cast<retType*>($1)->type, dynamic_cast<Id*>($2)->name);
																	std::string freshReg = RegisterGenerator::getRegister();
																	dynamic_cast<retType*>($4)->reg = freshReg;
																	string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(dynamic_cast<Id*>($2)->name));
                                                                    CodeBuffer::instance().emit(assignment_code);
																	delete dynamic_cast<retType*>($1); delete dynamic_cast<Id*>($2); delete dynamic_cast<retType*>($4);
																} |
				AUTO ID ASSIGN Exp SC	                        {
																	CheckIfValidTypeForVar(dynamic_cast<retType*>($4)->type);
																	MakeDeclaration(dynamic_cast<retType*>($4)->type, dynamic_cast<Id*>($2)->name);
																	std::string freshReg = RegisterGenerator::getRegister();
																	dynamic_cast<retType*>($4)->reg = freshReg;
																	string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(dynamic_cast<Id*>($2)->name));
                                                                    CodeBuffer::instance().emit(assignment_code);
																	delete dynamic_cast<retType*>($4); delete dynamic_cast<Id*>($2);
																} |
				ID ASSIGN Exp SC                	            {
																	CheckIfAssignmentValid(dynamic_cast<Id*>($1)->name, dynamic_cast<retType*>($3)->type);
																	string freshReg = RegisterGenerator::getRegister();
																	string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(dynamic_cast<Id*>($2)->name));
                                                                    CodeBuffer::instance().emit(assignment_code);
																	delete dynamic_cast<Id*>($1);delete dynamic_cast<retType*>($3);
																} |
				Call SC	                                        {
																	delete dynamic_cast<call2Fun*>($1);
																} |
				RETURN SC	                                    {
																	if(symbolTableManager.getCurrentScopeFunctionReturnType() != Type_::TYPE_VOID){output::errorMismatch(yylineno); exit(1);}} |
				RETURN Exp SC	                                {
																	if(isRetTypeMismatch(dynamic_cast<retType*>($2)->type))
																		{output::errorMismatch(yylineno); exit(1);} 
																	delete dynamic_cast<retType*>($2);
																}  |
																
				IF LPAREN Bool_Exp RPAREN M_INSTR Statement         {
																		$$ = new Statement();
																		Label* statement_label = dynamic_cast<Label*>($5);
																		Statement* exp = dynamic_cast<Statement*>($3);
																		Statement* statement = dynamic_cast<Statement*>($6);
																		codeBuff.bpatch(exp->trueList, statement_label);
																		$$->nextList = codeBuff.merge(exp->falseList, statement->nextList);
																		$$->breakList = statement->breakList;
																		$$->continueList = statement->continueList;
																		symbolTableManager.closeScope();
																		
																		delete statement_label;
																		delete exp;
																		delete statement;
																	} |
																	
																	
				IF LPAREN Bool_Exp RPAREN M_INSTR Statement M_JUMP ELSE {symbolTableManager.closeScope(); symbolTableManager.openScope();} M_INSTR Statement CLOSE_SCOPE	{
																																												$$ = new Statement();
																																												Label* if_body_label = dynamic_cast<Label*>($5);
																																												Label* else_label = dynamic_cast<Label*>($10);
																																												Statement* exp = dynamic_cast<Statement*>($3);
																																												Statement* if_statement = dynamic_cast<Statement*>($6);
																																												Statement* else_statement = dynamic_cast<Statement*>($11);
																																												JumpMarker* jump_over_else = dynamic_cast<JumpMarker*>($7);
																																												codeBuff.bpatch(exp->trueList, if_body_label);
																																												codeBuff.bpatch(exp->falseList, else_label);
																																												auto tmpList = codeBuff.merge(if_statement->nextList, jump_over_else->nextList);
																																												$$->nextList = codeBuff.merge(tmpList, else_statement->nextList);
																																												$$->breakList = codeBuff.merge(if_statement->breakList, else_statement->breakList);
																																												$$->continueList = codeBuff.merge(if_statement->continueList, else_statement->continueList);
																																												symbolTableManager.closeScope();
																																												
																																												delete if_body_label;
																																												delete else_label;
																																												delete exp;
																																												delete if_statement;
																																												delete else_statement;
																																												delete jump_over_else;
																																											} |
				
				WHILE M_INSTR LPAREN Exp RPAREN M_INSTR {
											symbolTableManager.openWhileScope(); 
											retType* exp = dynamic_cast<retType*>($4);
											CheckType(exp->type, Type_::TYPE_BOOL);
											string freshReg = RegisterGenerator::getRegister();
											string check_if_exp_false = freshReg + " = icmp eq i32 0, " + exp->reg;
											codeBuff.emit(check_if_exp_false);
											string branch_code = "br i1 " + freshReg + ", label @, label @";
											int branch_line = codeBuff.emit(branch_code);
											exp->trueList = codeBuff.makeList(branch_line, FIRST);
											exp->falseList = codeBuff.makeList(branch_line, SECOND);
										} 
										Statement CLOSE_SCOPE	       						
																{
																	Statement* statement = dynamic_cast<Statement*>($8);
																	retType* exp = dynamic_cast<retType*>($4);
																	Statement* while_statement = dynamic_cast<Statement*>($$);
																	std::string exp_label = dynamic_cast<Label*>($2)->label;
																	std::string statement_label = dynamic_cast<Label*>($6)->label;
																	codeBuff.bpatch(exp->trueList, statement_label);
																	codeBuff.bpatch(statement->nextList, exp_label);
																	codeBuff.bpatch(statement->continueList, exp_label);
																	while_statement->nextList = codeBuff.merge(exp->falseList, statement->breakList);
																	codeBuff.emit("br label " + exp_label);
																	
																	delete exp;
																	delete statement;
																} |
				
				BREAK SC	   
																																														{
																																															if (!(symbolTableManager.isWhileScoped()))
																																															{
																																																output::errorUnexpectedBreak(yylineno);
																																																exit(1);
																																															}
																																															Statement* breakStatement = dynamic_cast<Statement*>($1);
																																															string next_line = codeBuff.emit("br label @");
																																															breakStatement->nextList = codeBuff.makelist(next_line, BranchLabelIndex::FIRST);
																																															$$ = new Statement();
																																															$$->breakList = breakStatement->nextList;
																																															delete breakStatement;
																																														} |
																																														
				CONTINUE SC	                                    																														{
																																															if (!symbolTableManager.isWhileScoped()) 
																																															{
																																																output::errorUnexpectedContinue(yylineno); 
																																																exit(1);
																																															}
																																															Statement* contStatement = dynamic_cast<Statement*>($1);
																																															string next_line = codeBuff.emit("br label @");
																																															breakStatement->nextList = codeBuff.makelist(next_line, BranchLabelIndex::FIRST);
																																															$$ = new Statement();
																																															$$->continueList = contStatement->nextList;
																																															delete contStatement;
																																														}
				;
				
    Call: ID LPAREN ExpList RPAREN	                            {
																	$$ = new call2Fun(); checkIfFuncExist(dynamic_cast<Id*>($1)->name,dynamic_cast<expressionList*>($3)->exprList);
																	dynamic_cast<call2Fun*>($$)->name = dynamic_cast<Id*>($1)->name;
																	dynamic_cast<call2Fun*>($$)->expList = dynamic_cast<expressionList*>($3)->exprList;
																	dynamic_cast<call2Fun*>($$)->type = symbolTableManager.getFunctionReturnType(dynamic_cast<Id*>($1)->name);
																	delete dynamic_cast<Id*>($1); delete dynamic_cast<expressionList*>($3);
																} |
		  ID LPAREN RPAREN	                                    {
																	$$ = new call2Fun(); 
																	checkIfFuncExist(dynamic_cast<Id*>($1)->name,std::vector<Type_>());
																	dynamic_cast<call2Fun*>($$)->name = dynamic_cast<Id*>($1)->name;
																	dynamic_cast<call2Fun*>($$)->expList = std::vector<Type_>();
																	dynamic_cast<call2Fun*>($$)->type = symbolTableManager.getFunctionReturnType(dynamic_cast<Id*>($1)->name);
																	delete dynamic_cast<Id*>($1);
																}
		  ;
    ExpList: Exp	                                            {
																	$$ = new expressionList(); 
																	dynamic_cast<expressionList*>($$)->exprList = std::vector<Type_>(1,dynamic_cast<retType*>($1)->type);
																	delete dynamic_cast<retType*>($1);
																} |
		   	 Exp COMMA ExpList	                                {
																	$$ = new expressionList();
																	dynamic_cast<expressionList*>($$)->exprList = dynamic_cast<expressionList*>($3)->exprList;
																	dynamic_cast<expressionList*>($$)->insertElement(dynamic_cast<retType*>($1)->type);
																	delete dynamic_cast<expressionList*>($3);
																}
			 ;


    Type: INT	                                                {$$ = new retType(); dynamic_cast<retType*>($$)-> type = Type_::TYPE_INT;} |
		  BYTE	                                                {$$ = new retType(); dynamic_cast<retType*>($$)-> type = Type_::TYPE_BYTE;} |
       	  BOOL	                                                {$$ = new retType(); dynamic_cast<retType*>($$)-> type = Type_::TYPE_BOOL;}
		  ;


    Exp: LPAREN Exp RPAREN	                                    {$$ = new retType(); dynamic_cast<retType*>($$)->type= dynamic_cast<retType*>($2)->type;
                                                                delete dynamic_cast<retType*>($2); }|
																
														
         Exp BINOP_PLUS Exp	                            		{$$ = new retType(); 
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type == Type_::TYPE_INT)
                                                                {dynamic_cast<retType*>($$)->type=Type_::TYPE_INT;}
                                                                else {dynamic_cast<retType*>($$)->type = first->type;}
																CodeGenerator::generateAdditionCode(first, second, dynamic_cast<retType*>($$));
                                                                delete first; delete second;
																} |
																
		Exp BINOP_MINUS Exp	                            		{$$ = new retType(); 
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type==Type_::TYPE_INT)
                                                                {dynamic_cast<retType*>($$)->type=Type_::TYPE_INT;}
                                                                else {dynamic_cast<retType*>($$)->type=firstf->type;}
																CodeGenerator::generateSubtractionCode(first, second, dynamic_cast<retType*>($$));
                                                                delete dynamic_cast<retType*>($1); delete dynamic_cast<retType*>($3);
																} |

		 Exp BINOP_MUL Exp	                                	{
																$$ = new retType(); 
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type==Type_::TYPE_INT)
                                                                {dynamic_cast<retType*>($$)->type=Type_::TYPE_INT;}
                                                                else {dynamic_cast<retType*>($$)->type=first->type;}
																CodeGenerator::generateMultiplicationCode(first, second, dynamic_cast<retType*>($$));
                                                                delete dynamic_cast<retType*>($1); delete dynamic_cast<retType*>($3);
																} |
																
		 Exp BINOP_DIV Exp	                                	{
																$$ = new retType(); 
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type==Type_::TYPE_INT)
                                                                {dynamic_cast<retType*>($$)->type=Type_::TYPE_INT;}
                                                                else {dynamic_cast<retType*>($$)->type=first->type;}
																CodeGenerator::generateDivisionCode(first, second, dynamic_cast<retType*>($$));
                                                                delete dynamic_cast<retType*>($1); delete dynamic_cast<retType*>($3);
																} |

         ID          	                                        {
																	$$ = new retType();
																	Type_ type = symbolTableManager.getVarType(dynamic_cast<Id*>($1)->name);
																	if(type == Type_::TYPE_NOT_VALID || (symbolTableManager.isFunction(dynamic_cast<Id*>($1)->name)))
																	{
																		output::errorUndef(yylineno, dynamic_cast<Id*>($1)->name); 
																		exit(1);
																	}
																
																	string id_reg = symbolTableManager.getVarRegister(dynamic_cast<Id*>($1)->name);
																	string result_register = RegisterGenerator::getRegister();
																	dynamic_cast<retType*>($$)->type = type;
																	dynamic_cast<retType*>($$)->reg = result_register;
																	string code = result_register + " = load i32, i32* " + id_reg;
																	CodeBuffer::instance().emit(code);
																	delete dynamic_cast<Id*>($1);
																} |
         Call        	                                        {$$ = new retType(); dynamic_cast<retType*>($$)->type = dynamic_cast<call2Fun*>($1)->type;
                                                                delete dynamic_cast<call2Fun*>($1);} |

         NUM         	                                        {
																	$$ = new retType();
																	retType* ret = dynamic_cast<retType*>($$);
																	Num* num = dynamic_cast<Num*>($1);
																	std::string reg = RegisterGenerator::getRegister();
																	ret->type = Type_::TYPE_INT ;
																	ret->reg = reg;
																	CodeGenerator::generateIntByteCreationCode(reg, num->value);
																	delete num;
																} |
         NUM B       	                                        {
																	$$ = new retType();
																	retType* ret = dynamic_cast<retType*>($$);
																	Num* num = dynamic_cast<Num*>($1);
																	if(std::stoi(num->value) >= 256) {
																		output::errorByteTooLarge(yylineno, num->value); 
																		exit(1);
																	}
																	std::string reg = RegisterGenerator::getRegister();
																	ret->type = Type_::TYPE_BYTE;
																	ret->reg = reg;
																	CodeGenerator::generateIntByteCreationCode(reg, num->value);
																	delete num;
																} |
         STRING      	                                        {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_STRING ;} |
		 
         TRUE        	                                        {
																	$$ = new retType();
																	retType* result = dynamic_cast<retType*>($$);
																	result->type = Type_::TYPE_BOOL ;
																	int lineOfCode = codeBuff.emit("br label @");
                                                                    result->trueList.push_back({lineOfCode, BranchLabelIndex::FIRST});
																} |
																
         FALSE       	                                        {
																	$$ = new retType(); 
																	retType* result = dynamic_cast<retType*>($$);
																	result->type = Type_::TYPE_BOOL ;
																	int lineOfCode = codeBuff.emit("br label @");
                                                                    result->falseList.push_back({lineOfCode, BranchLabelIndex::FIRST});
																} |
																
         NOT Exp     	                                        {
																	$$ = new retType(); 
																	retType* ret = dynamic_cast<retType*>($$);
																	retType* exp = dynamic_cast<retType*>($2);
																	CheckType(exp->type, Type_::TYPE_BOOL);
																	ret->type = Type_::TYPE_BOOL;
																	ret->trueList = exp->falseList;
																	ret->falseList = exp->trueList;
																	delete dynamic_cast<retType*>($2);
																} |
																
         Exp AND M_INSTR Exp 	                                {
																	$$ = new retType(); 
																	retType* result = dynamic_cast<retType*>($$);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($4);
																	CheckType(exp1->type, Type_::TYPE_BOOL);
																	CheckType(exp2->type, Type_::TYPE_BOOL);
																	result->type = Type_::TYPE_BOOL;
																	codeBuff.bpatch(exp1->trueList, dynamic_cast<Label*>($3)->label);
																	result->trueList = exp2->trueList;
																	result->falseList = codeBuff.merge(exp1->falseList, exp2->falseList);
																	delete exp1; 
																	delete exp2;
																} |
																
         Exp OR M_INSTR Exp		                                {
																	$$ = new retType();
																	retType* result = dynamic_cast<retType*>($$);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($4);
																	CheckType(exp1->type, Type_::TYPE_BOOL);
																	CheckType(exp2->type, Type_::TYPE_BOOL);
																	result->type = Type_::TYPE_BOOL;
																	codeBuff.bpatch(exp1->falseList, dynamic_cast<Label*>($3)->label);
																	result->falseList = exp2->falseList;
																	result->trueList = codeBuff.merge(exp1->trueList, exp2->trueList);
																	delete exp1;
																	delete exp2;
																} |
																
         Exp RELOP_EQ Exp                                 		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode = freshReg + " = icmp eq i32 " + exp1->reg + ", " + exp2->reg;
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} |
																
		Exp RELOP_NOTEQ Exp                                 	{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode = freshReg + " = icmp ne i32 " + exp1->reg + ", " + exp2->reg;
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} |
																
		 Exp RELOP_LESS Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ult i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp slt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_GREATER Exp                               	{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ugt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sgt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_LEQ Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ule i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sle i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_GEQ Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp uge i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sge i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	codeBuff.emit(comparisonCode);
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
         LPAREN Type RPAREN Exp	                                {
																	$$ = new retType();
																	if(!(((dynamic_cast<retType*>($2)->type == Type_::TYPE_INT)  && (dynamic_cast<retType*>($4)->type == Type_::TYPE_BYTE))
																	||  ((dynamic_cast<retType*>($2)->type == Type_::TYPE_BYTE)  && (dynamic_cast<retType*>($4)->type == Type_::TYPE_INT))
																	|| ((dynamic_cast<retType*>($2)->type == dynamic_cast<retType*>($4)->type))))
																	{output::errorMismatch(yylineno);exit(1);}
																	dynamic_cast<retType*>($$)->type= dynamic_cast<retType*>($2)->type ;
																	delete dynamic_cast<retType*>($2); delete dynamic_cast<retType*>($4);
																}
	;
	
	CLOSE_SCOPE: {symbolTableManager.closeScope();};
	Bool_Exp: Exp 	{
						retType* exp = dynamic_cast<retType*>($1);
						CheckType(exp->type, Type_::TYPE_BOOL);
						//BUG: maybe here.
						int branch_line = codeBuff.emit("br i1 " + exp->reg + ", label @, label @");
						exp->trueList = codeBuff.makeList(branch_line, FIRST);
						exp->falseList = codeBuff.makeList(branch_line, SECOND);
						$$ = $1;
						symbolTableManager.openScope();
					};
					
	M_INSTR : {$$ = new Label(codeBuff.genLabel());};
	
	M_JUMP: {
				$$ = new JumpMarker();
				int line = codeBuff.emit("br label @");
				$$->nextList = codeBuff.makeList(line, FIRST);
			};

%%

int main()
{
    return yyparse();
}

void yyerror(const char* message)
{
    output::errorSyn(yylineno);
    exit(1);
}

void InsertPrintFunctions()
{
	std::shared_ptr<SymbolTable> globalScope = symbolTableManager.top();
	std::vector<Type_> printParams = std::vector<Type_>(1, Type_::TYPE_STRING);
	SymbolTableEntry entry = SymbolTableEntry("print", Type_::TYPE_VOID, 0, printParams); 
	globalScope->table.push_back(entry);
	
	std::vector<Type_> printIParams = std::vector<Type_>(1, Type_::TYPE_INT);
	entry = SymbolTableEntry("printi", Type_::TYPE_VOID, 0, printIParams);
	globalScope->table.push_back(entry);
}

void CheckType( Type_ target, Type_ given)
{
    if ((target == TYPE_INT && given == TYPE_BYTE))
    {
        return;
    }
    if (target != given)
    {
        output::errorMismatch(yylineno);
        exit(1);
    }
}

void checkIfVarExists(Type_ type, const std::string& name)
{
    if(symbolTableManager.doesSymbolExists(type, name))
    {
        output::errorDef(yylineno, name);
        exit(1);
    }
}

void MakeDeclaration(Type_ type, const std::string& name)
{
    checkIfVarExists(type, name);
    symbolTableManager.top()->Insert(name, type, symbolTableManager.getOffset());
}

void checkIfFuncExist(const std::string& name, std::vector<Type_> params)
{
    if (!symbolTableManager.isFunction(name)) // no matching name for func
    {
          output::errorUndefFunc(yylineno, name);
          exit(1);
    }
    if(symbolTableManager.doesFunctionExist(name, params) == Type_::TYPE_NOT_VALID) // no right params
    {
       std::vector<std::string> real_params = symbolTableManager.getParamList(name);
       output::errorPrototypeMismatch(yylineno, name, real_params);
       exit(1);
    }
}

void CheckIfAssignmentValid(const std::string& name, Type_ type2)
{
	Type_ type1 = symbolTableManager.getVarType(name);
	if(Type_::TYPE_NOT_VALID == type1)
	{
		output::errorUndef(yylineno, name);
		exit(1);
	}
	CheckType(type1,type2);
}

void checkIfNumType(Type_ type)
{
	if((type != Type_::TYPE_INT) && (type != Type_::TYPE_BYTE))
	{
		output::errorMismatch(yylineno);
        exit(1);
	}
}

void checkIfDoubleDeclare(const std::string& name, std::vector<std::string>names_in_list)
{
    for (auto it = names_in_list.begin(); it != names_in_list.end(); it++)
    {
        for (std::vector<std::string>::iterator it2 = it; it2 != names_in_list.end(); it2++)
        {
            if ((*it2 == *it) && (it != it2)) //same parameter name twice
            {
                  output::errorDef(yylineno, *it2);
                  exit(1);
            }
        }
    }
    for (auto it = names_in_list.begin(); it != names_in_list.end(); it++)
    {
        if (*it == name) //param is equal to func name
        {
            output::errorDef(yylineno, name);
            exit(1);
        }
    }
}

bool isRetTypeMismatch(Type_ expType)
{
	return (
			((symbolTableManager.getCurrentScopeFunctionReturnType() != expType) &&
			
			(expType != Type_::TYPE_BYTE || (symbolTableManager.getCurrentScopeFunctionReturnType() != Type_::TYPE_INT)))
			
			|| (Type_::TYPE_VOID == symbolTableManager.getCurrentScopeFunctionReturnType()));
}

void checkIfMainRedefined(const std::string& functionName)
{
	if(symbolTableManager.isFunction(functionName))
	{
		output::errorDef(yylineno, functionName);
		exit(1);
	}
}

void CheckIfValidTypeForVar(const Type_ type_to_assign)
{
	if(TYPE_VOID == type_to_assign || TYPE_STRING == type_to_assign || TYPE_NOT_VALID == type_to_assign)
	{
		output::errorMismatch(yylineno);
		exit(1);
	}
}

void debug()
{
	cout << "debug" << endl;
}


