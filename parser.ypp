%{
#include <iostream>
#include <stdlib.h>
#include "SymbolTableManager.h"
#include "CodeGenerator.h"
#include "hw3_output.hpp"


int yylex();
void yyerror (const char*);
extern int yylineno;

SymbolTableManager symbolTableManager = SymbolTableManager();
CodeBuffer& codeBuff = CodeBuffer::instance();

void CheckType( Type_ target, Type_ given);
void checkIfVarExists(Type_ type, const std::string& name);
void MakeDeclaration(Type_ type, const std::string& name);
void checkIfFuncExist(const std::string& name, std::vector<Type_> params);
void CheckIfAssignmentValid(const std::string& name, Type_ type2);
void checkIfNumType(Type_ type);
void InsertPrintFunctions();
void checkIfDoubleDeclare(const std::string& name, std::vector<std::string>names_in_list);
bool isRetTypeMismatch(Type_ expType);
void checkIfMainRedefined(const std::string& functionName);
void CheckIfValidTypeForVar(const Type_ type_to_assign);
void debug();

using namespace std;
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%left OR
%left AND
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%right IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc COMMA
%nonassoc SC
%nonassoc ID
%right ASSIGN
%left RELOP_EQ
%left RELOP_NOTEQ
%left RELOP_LESS
%left RELOP_GREATER
%left RELOP_LEQ
%left RELOP_GEQ
%left BINOP_PLUS
%left BINOP_MINUS
%left BINOP_MUL
%left BINOP_DIV
%right NOT
%nonassoc NUM
%nonassoc STRING
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%right ELSE
%%
    Program: {symbolTableManager.openScope(); InsertPrintFunctions(); CodeGenerator::generateStandardLibraryFunctionsDeclaration(); CodeGenerator::generatePrintFunctions();} Funcs	        {
																																											
																																																if(Type_::TYPE_VOID != symbolTableManager.doesFunctionExist("main", vector<Type_>())) 
																																																	{output::errorMainMissing(); exit(1);}
																																																codeBuff.printGlobalBuffer();
																																																codeBuff.printCodeBuffer();
																																																symbolTableManager.closeScope();
																																															}
            ;

    Funcs:                   	                                {}
			| FuncDecl Funcs	                                {}
	        ;


    FuncDecl: {symbolTableManager.openFuncScope();} FuncDeclaration FuncBody CLOSE_SCOPE 	{
																								StatementNode* funcBody = dynamic_cast<StatementNode*>($3);
																								call2Fun* funcDeclaration = dynamic_cast<call2Fun*>($2);
																								int loc = CodeBuffer::instance().emit("br label @");
																								auto jump_list = codeBuff.makelist({loc, FIRST});
																								string label = codeBuff.genLabel();
																								codeBuff.bpatch(jump_list, label);
																								codeBuff.bpatch(funcBody->nextList, label);
																								if(TYPE_VOID == funcDeclaration->type)
																								{
																									codeBuff.emit("ret void");
																								}
																								else
																								{
																									codeBuff.emit("ret i32 0");
																								}
																								string close_scope = "}";
																								codeBuff.emit(close_scope);
																							};
	
	FuncDeclaration: retType ID LPAREN Formals RPAREN 												{
																										retType* returnType = dynamic_cast<retType*>($1);
																										Id* id = dynamic_cast<Id*>($2);
																										paramList* params = dynamic_cast<paramList*>($4);
																										checkIfMainRedefined(id->name);
																										checkIfDoubleDeclare(id->name, params->names_in_list);
																										symbolTableManager.top()->InsertFunction(id->name, returnType->type, 0, params->types_in_list, params->names_in_list);
																										$$ = new call2Fun();
																										call2Fun* result = dynamic_cast<call2Fun*>($$);
																										result->name = id->name;
																										result->type = returnType->type;
																										result->expList = params->types_in_list;
																										string sType = symbolTableManager.ConvertTypeToLlvmType(result->type);
																										int paramsListSize = params->types_in_list.size();
																										string sParams = "(";
																										for (int i=0; i < paramsListSize; i++)
																										{
																											sParams += SymbolTableManager::ConvertTypeToLlvmType(params->types_in_list[i]);
																											if(i< paramsListSize-1)
																											{
																												sParams += ", ";
																											}
																										}
																										sParams += ")";
																										string code = "define " + sType + " @" + result->name + sParams;
																										codeBuff.emit(code);
																										string open_scope = "{";
																										codeBuff.emit(open_scope);
																										for (int i=0; i < paramsListSize; i++)
																										{
																											string reg = RegisterGenerator::getRegister();
																											string varName = params->names_in_list[i];
																											symbolTableManager.assignRegisterToVar(varName, reg);
																											string allocationCommand = reg + " = alloca i32";
																											codeBuff.emit(allocationCommand);
																										}
																										for (int i=0; i < paramsListSize; i++)
																										{
																											string var = params->names_in_list[i];
																											string storeCommand = "store i32 %" + to_string(i) + " ,i32* " + symbolTableManager.getVarRegister(var);
																											codeBuff.emit(storeCommand);
																										}
																										string stackVar = RegisterGenerator::getRegister() + "sp";
																										string stackPointer = symbolTableManager.getStackPointer();
																										stackPointer = stackVar;
																										code = stackVar + " = alloca [50 x i32]";
																										CodeBuffer::instance().emit(code);
																										delete dynamic_cast<retType*>($1); delete dynamic_cast<Id*>($2); 
																										delete dynamic_cast<paramList*>($4);
																									};
	FuncBody: LBRACE Statements RBRACE 																{
																										$$ = $2;
																									};


    retType: /*epsilon*/										{output::errorSyn(yylineno);exit(1);} |
			 Type	                                            {$$ = new retType(); dynamic_cast<retType*>($$)->type = dynamic_cast<retType*>($1)->type; delete dynamic_cast<retType*>($1);} |
			 VOID	                                            {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_VOID;}
			 ;


    Formals: /*epsilon*/	                                    {$$ = new paramList();} |
             FormalsList	                                    {
																	$$ = new paramList();
																	dynamic_cast<paramList*>($$)-> names_in_list = dynamic_cast<paramList*>($1)->names_in_list;
																	dynamic_cast<paramList*>($$) -> types_in_list = dynamic_cast<paramList*>($1) -> types_in_list;
																	delete dynamic_cast<retType*>($1);
																}
			 ;														

    FormalsList: FormalDecl	                                     {
																	$$ = new paramList();					
																	paramList* list = dynamic_cast<paramList*>($$);
																	list->names_in_list = std::vector<std::string>();
																	list->names_in_list.push_back(dynamic_cast<Param*>($1)->name);
																	dynamic_cast<paramList*>($$) -> types_in_list = std::vector<Type_>();
																	list->types_in_list.push_back(dynamic_cast<Param*>($1)->type);															
																	delete dynamic_cast<Param*>($1);
																 } |
				FormalDecl COMMA FormalsList                     {$$ = new paramList();
																 paramList* formals_list = dynamic_cast<paramList*>($$);
																 Param* formal_decl = dynamic_cast<Param*>($1);
																 paramList* formal_decl_list = dynamic_cast<paramList*>($3);
				                                                 formals_list-> names_in_list = formal_decl_list->names_in_list;
				                                                 formals_list-> types_in_list = formal_decl_list-> types_in_list;
																 formals_list->names_in_list.insert(formals_list->names_in_list.begin(), formal_decl->name);
																 formals_list->types_in_list.insert(formals_list->types_in_list.begin(), formal_decl->type);
				                                                 delete formal_decl;
																 delete formal_decl_list;
																 }
				;


    FormalDecl: Type ID	                            			{
																	checkIfVarExists(dynamic_cast<retType*>($1) -> type, dynamic_cast<Id*>($2) -> name);
																	$$ = new Param(dynamic_cast<retType*>($1) -> type, dynamic_cast<Id*>($2)->name);
																	delete dynamic_cast<retType*>($1);  
																	delete dynamic_cast<Id*>($2); 
																}

	;


    Statements: Statement	                                    {
																	$$ = new StatementNode();
																	StatementNode* s = dynamic_cast<StatementNode*>($1);
																	StatementNode* resultStatement = dynamic_cast<StatementNode*>($$);
																	resultStatement->nextList = s->nextList;
																	resultStatement->breakList = s->breakList;
																	resultStatement->continueList = s->continueList;
																	delete s;
																} |
				Statements M_JUMP M_INSTR  Statement	        { //BUG: maybe here
																	$$ = new StatementNode();
																	StatementNode* resultStatement = dynamic_cast<StatementNode*>($$);
																	StatementNode* last = dynamic_cast<StatementNode*>($4);
																	StatementNode* rest = dynamic_cast<StatementNode*>($1);
																	Label* to_jump = dynamic_cast<Label*>($3);
																	JumpMarker* jump = dynamic_cast<JumpMarker*>($2);
																	codeBuff.bpatch(rest->nextList, to_jump->label);
																	codeBuff.bpatch(jump->nextList, to_jump->label);
																	resultStatement->nextList = last->nextList;
																	resultStatement->breakList = codeBuff.merge(rest->breakList, last->breakList);
																	resultStatement->continueList = codeBuff.merge(rest->continueList, last->continueList);
																	delete last;
																	delete rest;
																	delete jump;
																	delete to_jump;
																}
				;


	Statement:
				LBRACE {symbolTableManager.openScope();} Statements RBRACE	{
																				$$ = new StatementNode();
																				StatementNode* resultStatement = dynamic_cast<StatementNode*>($$);
																				StatementNode* inner = dynamic_cast<StatementNode*>($3);
																				resultStatement->nextList = inner->nextList;
																				resultStatement->breakList = inner->breakList;
																				resultStatement->continueList = inner->continueList;
																				symbolTableManager.closeScope();
																				delete inner;
																			} |
				
				Type ID SC	                                    {
																	MakeDeclaration(dynamic_cast<retType*>($1)->type, dynamic_cast<Id*>($2)->name);
																	
																	$$ = new StatementNode();
																	int offset = symbolTableManager.getVarOffset(dynamic_cast<Id*>($2)->name);
																	if(offset >= 0)
																	{
																		string reg = RegisterGenerator::getRegister();
																		string code = reg + " = getelementptr [50 x i32], [50 x i32]* " + symbolTableManager.getStackPointer() + ", i32 0 , i32 " + to_string(offset);
																		CodeBuffer::instance().emit(code);
																		symbolTableManager.assignRegisterToVar(dynamic_cast<Id*>($2)->name, reg);
																		code = "store i32 0, i32* " + reg;
																		CodeBuffer::instance().emit(code);
																	}
																	delete dynamic_cast<Id*>($2);
																	delete dynamic_cast<retType*>($1);
																} |
																
				Type ID									{
															retType* varType = dynamic_cast<retType*>($1);
															Id* id = dynamic_cast<Id*>($2);
															checkIfVarExists(varType->type, id->name);
															int offset = symbolTableManager.getVarOffset(id->name);
															//If var already exists we update it on the stack.
															if(offset >= 0)
															{
																string updatedReg = CodeGenerator::generateUpdateRegisterOnStackCode(offset, symbolTableManager.getStackPointer());
																symbolTableManager.assignRegisterToVar(id->name, updatedReg);
															}
														}					
				ASSIGN Exp SC	                        { 
															$$ = new StatementNode();
															retType* varType = dynamic_cast<retType*>($1);
															retType* exp = dynamic_cast<retType*>($5);
															Id* id = dynamic_cast<Id*>($2);
															CheckType(varType->type, exp->type);
															MakeDeclaration(varType->type, id->name);
															std::string freshReg = RegisterGenerator::getRegister();
															//symbolTableManager.assignRegisterToVar(id->name, freshReg);
															if(TYPE_BOOL == exp->type && exp->reg == "")
															{
																CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, freshReg);
															}
															else
															{
																CodeGenerator::generateInitNewVar(freshReg, exp->reg);
															}
															string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(id->name);
                                                                  CodeBuffer::instance().emit(assignment_code);
															delete dynamic_cast<retType*>($1); delete dynamic_cast<Id*>($2); delete dynamic_cast<retType*>($4);
														} |
				AUTO ID ASSIGN Exp SC	                        {
																	//BUG
																	$$ = new StatementNode();
																	retType* exp = dynamic_cast<retType*>($4);
																	Id* id = dynamic_cast<Id*>($2);
																	CheckIfValidTypeForVar(exp->type);
																	MakeDeclaration(exp->type, id->name);
																	std::string freshReg = RegisterGenerator::getRegister();
																	//id->reg = freshReg;
																	if(TYPE_BOOL == exp->type)
																	{
																		CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, freshReg);
																	}
																	string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(id->name);
                                                                    CodeBuffer::instance().emit(assignment_code);
																	delete exp; 
																	delete id;
																} |
				ID ASSIGN Exp SC                	            {
																	//BUG
																	$$ = new StatementNode();
																	retType* exp = dynamic_cast<retType*>($3);
																	Id* id = dynamic_cast<Id*>($1);
																	CheckIfAssignmentValid(id->name, exp->type);
																	string freshReg = RegisterGenerator::getRegister();
																	if(TYPE_BOOL == exp->type)
																	{
																		CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, freshReg);
																	}
																	string assignment_code = "store i32 " + freshReg + " ,i32*" + symbolTableManager.getVarRegister(dynamic_cast<Id*>($2)->name);
                                                                    CodeBuffer::instance().emit(assignment_code);
																	delete id;
																	delete exp;
																} |
				Call SC	                                        {
																	$$ = new StatementNode();
																	call2Fun* func_call = dynamic_cast<call2Fun*>($1);
																	
																	delete func_call;
																} |
				RETURN SC	                                    {
																	$$ = new StatementNode();
																	if(symbolTableManager.getCurrentScopeFunctionReturnType() != Type_::TYPE_VOID)
																	{
																		output::errorMismatch(yylineno); 
																		exit(1);
																	}
																	codeBuff.emit("ret void");
																} |
																
				RETURN Exp SC	                                {
																	//BUG: maybe here
																	$$ = new StatementNode();
																	retType* exp = dynamic_cast<retType*>($2);
																	if(isRetTypeMismatch(exp->type))
																	{
																		output::errorMismatch(yylineno); 
																		exit(1);
																	} 
																	string freshReg = exp->reg;
																	if(exp->reg == "" && TYPE_BOOL == exp->type)
																	{
																		freshReg = RegisterGenerator::getRegister();
																		CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, freshReg);
																	}
																	std::string exp_type = symbolTableManager.ConvertTypeToLlvmType(exp->type);
																	codeBuff.emit("ret " + exp_type + " " + freshReg);
																	delete exp;
																}  |
																
				IF LPAREN Bool_Exp RPAREN M_INSTR Statement         {
																		$$ = new StatementNode();
																		StatementNode* resultStatement = dynamic_cast<StatementNode*>($$);
																		Label* statement_label = dynamic_cast<Label*>($5);
																		retType* exp = dynamic_cast<retType*>($3);
																		StatementNode* statement = dynamic_cast<StatementNode*>($6);
																		codeBuff.bpatch(exp->trueList, statement_label->label);
																		resultStatement->nextList = codeBuff.merge(exp->falseList, statement->nextList);
																		resultStatement->breakList = statement->breakList;
																		resultStatement->continueList = statement->continueList;
																		symbolTableManager.closeScope();
																		
																		delete statement_label;
																		delete exp;
																		delete statement;
																	} |
																	
																	
				IF LPAREN Bool_Exp RPAREN M_INSTR Statement ELSE M_JUMP {symbolTableManager.closeScope(); symbolTableManager.openScope();} M_INSTR Statement CLOSE_SCOPE	{
																																												$$ = new StatementNode();
																																												StatementNode* resultStatement = dynamic_cast<StatementNode*>($$);
																																												Label* if_body_label = dynamic_cast<Label*>($5);
																																												Label* else_label = dynamic_cast<Label*>($10);
																																												retType* exp = dynamic_cast<retType*>($3);
																																												StatementNode* if_statement = dynamic_cast<StatementNode*>($6);
																																												StatementNode* else_statement = dynamic_cast<StatementNode*>($11);
																																												JumpMarker* jump_over_else = dynamic_cast<JumpMarker*>($8);
																																												codeBuff.bpatch(exp->trueList, if_body_label->label);
																																												codeBuff.bpatch(exp->falseList, else_label->label);
																																												auto tmpList = codeBuff.merge(if_statement->nextList, jump_over_else->nextList);
																																												resultStatement->nextList = codeBuff.merge(tmpList, else_statement->nextList);
																																												resultStatement->breakList = codeBuff.merge(if_statement->breakList, else_statement->breakList);
																																												resultStatement->continueList = codeBuff.merge(if_statement->continueList, else_statement->continueList);
																																												//symbolTableManager.closeScope();
																																												delete if_body_label;
																																												delete else_label;
																																												delete exp;
																																												delete if_statement;
																																												delete else_statement;
																																												delete jump_over_else;
																																											} |
				
				WHILE M_INSTR LPAREN Exp RPAREN M_INSTR {
											symbolTableManager.openWhileScope(); 
											retType* exp = dynamic_cast<retType*>($4);
											CheckType(exp->type, Type_::TYPE_BOOL);
											string freshReg = RegisterGenerator::getRegister();
											string check_if_exp_false = freshReg + " = icmp eq i32 0, " + exp->reg;
											codeBuff.emit(check_if_exp_false);
											string truncReg;
											if(TYPE_BOOL != exp->type)
											{											
												truncReg = CodeGenerator::generateTruncRegisterCode(freshReg);
											}
											string branch_code = "br i1 " + truncReg + ", label @, label @";
											int branch_line = codeBuff.emit(branch_code);
											exp->trueList = codeBuff.makelist({branch_line, FIRST});
											exp->falseList = codeBuff.makelist({branch_line, SECOND});
										} 
										Statement CLOSE_SCOPE	       						
																{
																	$$ = new StatementNode();
																	StatementNode* statement = dynamic_cast<StatementNode*>($8);
																	retType* exp = dynamic_cast<retType*>($4);
																	StatementNode* while_statement = dynamic_cast<StatementNode*>($$);
																	std::string exp_label = dynamic_cast<Label*>($2)->label;
																	std::string statement_label = dynamic_cast<Label*>($6)->label;
																	codeBuff.bpatch(exp->trueList, statement_label);
																	codeBuff.bpatch(statement->nextList, exp_label);
																	codeBuff.bpatch(statement->continueList, exp_label);
																	while_statement->nextList = codeBuff.merge(exp->falseList, statement->breakList);
																	codeBuff.emit("br label " + exp_label);
																	
																	delete exp;
																	delete statement;
																} |
				
				BREAK SC	   
																{
																	if (!(symbolTableManager.isWhileScoped()))
																	{
																		output::errorUnexpectedBreak(yylineno);
																		exit(1);
																	}
																	StatementNode* breakStatement = dynamic_cast<StatementNode*>($1);
																	int next_line = codeBuff.emit("br label @");
																	breakStatement->nextList = codeBuff.makelist({next_line, FIRST});
																	$$ = new StatementNode();
																	dynamic_cast<StatementNode*>($$)->breakList = breakStatement->nextList;
																	delete breakStatement;
																} |
																																														
				CONTINUE SC	                                    {																																															if (!symbolTableManager.isWhileScoped()) 
																	{
																		output::errorUnexpectedContinue(yylineno); 
																		exit(1);
																	}
																	StatementNode* contStatement = dynamic_cast<StatementNode*>($1);
																	int next_line = codeBuff.emit("br label @");
																	contStatement->nextList = codeBuff.makelist({next_line, FIRST});
																	$$ = new StatementNode();
																	dynamic_cast<StatementNode*>($$)->continueList = contStatement->nextList;
																	delete contStatement;
																}
				;
				
    Call: ID LPAREN ExpList RPAREN	                            {
																	$$ = new call2Fun();
																	call2Fun* func = dynamic_cast<call2Fun*>($$);
																	Id* func_id = dynamic_cast<Id*>($1);
																	expressionList* params = dynamic_cast<expressionList*>($3);
																	checkIfFuncExist(func_id->name, params->exprList);
																	func->name = func_id->name;
																	func->expList = params->exprList;
																	func->type = symbolTableManager.getFunctionReturnType(func_id->name);
																	func->reg = CodeGenerator::generateFunctionCallCode(func, func_id, params);
																	
																	delete func_id; 
																	delete params;
																} |
		  ID LPAREN RPAREN	                                    {
																	$$ = new call2Fun(); 
																	call2Fun* result = dynamic_cast<call2Fun*>($$);
																	Id* id = dynamic_cast<Id*>($1);
																	checkIfFuncExist(id->name, std::vector<Type_>());
																	result->name = id->name;
																	result->expList = std::vector<Type_>();
																	result->type = symbolTableManager.getFunctionReturnType(id->name);
																	
																	CodeGenerator::generateCallToFuncWithoutArguments(result);
																	delete id;
																}
		  ;
    ExpList: Exp	                                            {
																	$$ = new expressionList();
																	expressionList* result = dynamic_cast<expressionList*>($$);
																	retType* exp = dynamic_cast<retType*>($1);
																	if(TYPE_BOOL == exp->type && "" == exp->reg)
																	{
																		exp->reg = RegisterGenerator::getRegister();
																		CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, exp->reg);
																	}
																	result->exprList = std::vector<Type_>();
																	result->registersList = std::vector<std::string>();
																	result->insertElement(exp->type);
																	result->insertRegister(exp->reg);
																	delete exp;
																} |
		   	 Exp COMMA ExpList	                                {
																	$$ = new expressionList();
																	expressionList* result = dynamic_cast<expressionList*>($$);
																	retType* exp = dynamic_cast<retType*>($1);
																	expressionList* expList = dynamic_cast<expressionList*>($3);
																	if(TYPE_BOOL == exp->type && "" == exp->reg)
																	{
																		exp->reg = RegisterGenerator::getRegister();
																		CodeGenerator::generateBoolExpressionBackPatchLabels(exp->trueList, exp->falseList, exp->reg);
																	}
																	result->exprList = expList->exprList;
																	result->insertElement(exp->type);
																	result->registersList = expList->registersList;
																	result->insertRegister(exp->reg);
																	delete exp;
																	delete expList;
																}
			 ;


    Type: INT	                                                {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_INT;} |
		  BYTE	                                                {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_BYTE;} |
       	  BOOL	                                                {$$ = new retType(); dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;}
		  ;


    Exp: LPAREN Exp RPAREN	                                    {$$ = new retType(); dynamic_cast<retType*>($$)->type= dynamic_cast<retType*>($2)->type;
                                                                delete dynamic_cast<retType*>($2); }|
																
														
         Exp BINOP_PLUS Exp	                            		{$$ = new retType(); 
																retType* result = dynamic_cast<retType*>($$);
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type == Type_::TYPE_INT)
                                                                {
																	result->type = Type_::TYPE_INT;
																}
                                                                else 
																{
																	result->type = first->type;
																}
																result->reg = RegisterGenerator::getRegister();
																CodeGenerator::generateAdditionCode(first, second, result, result->reg);
                                                                delete first; delete second;
																} |
																
		Exp BINOP_MINUS Exp	                            		{
																	$$ = new retType(); 
																	retType* result = dynamic_cast<retType*>($$);
																	retType* first = dynamic_cast<retType*>($1);
																	retType* second = dynamic_cast<retType*>($3);
																	checkIfNumType(first->type);
																	checkIfNumType(second->type);
																	if(second->type==Type_::TYPE_INT)
																	{
																		result->type = Type_::TYPE_INT;
																	}
																	else 
																	{
																		result->type = first->type;
																	}
																	result->reg = RegisterGenerator::getRegister();
																	CodeGenerator::generateSubtractionCode(first, second, result, result->reg);
																	delete first; 
																	delete second;
																} |

		 Exp BINOP_MUL Exp	                                	{
																$$ = new retType(); 
																retType* result = dynamic_cast<retType*>($$);
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type==Type_::TYPE_INT)
                                                                {result->type=Type_::TYPE_INT;}
                                                                else {result->type=first->type;}
																result->reg = RegisterGenerator::getRegister();
																CodeGenerator::generateMultiplicationCode(first, second, result, result->reg);
                                                                delete dynamic_cast<retType*>($1); delete dynamic_cast<retType*>($3);
																} |
																
		 Exp BINOP_DIV Exp	                                	{
																$$ = new retType(); 
																retType* result = dynamic_cast<retType*>($$);
																retType* first = dynamic_cast<retType*>($1);
																retType* second = dynamic_cast<retType*>($3);
																checkIfNumType(first->type);
																checkIfNumType(second->type);
                                                                if(second->type==Type_::TYPE_INT)
                                                                {result->type=Type_::TYPE_INT;}
                                                                else {result->type=first->type;}
																result->reg = RegisterGenerator::getRegister();
																CodeGenerator::generateDivisionCode(first, second, result, result->reg);
                                                                delete dynamic_cast<retType*>($1); delete dynamic_cast<retType*>($3);
																} |

         ID          	                                        {
																	$$ = new retType();
																	Type_ type = symbolTableManager.getVarType(dynamic_cast<Id*>($1)->name);
																	if(type == Type_::TYPE_NOT_VALID || (symbolTableManager.isFunction(dynamic_cast<Id*>($1)->name)))
																	{
																		output::errorUndef(yylineno, dynamic_cast<Id*>($1)->name); 
																		exit(1);
																	}
																
																	string id_reg = symbolTableManager.getVarRegister(dynamic_cast<Id*>($1)->name);
																	string result_register = RegisterGenerator::getRegister();
																	dynamic_cast<retType*>($$)->type = type;
																	dynamic_cast<retType*>($$)->reg = result_register;
																	string code = result_register + " = load i32, i32* " + id_reg;
																	CodeBuffer::instance().emit(code);
																	delete dynamic_cast<Id*>($1);
																} |
         Call        	                                        {
																	$$ = new retType();
																	dynamic_cast<retType*>($$)->type = dynamic_cast<call2Fun*>($1)->type;
																	dynamic_cast<retType*>($$)->reg = dynamic_cast<call2Fun*>($1)->reg;
																	delete dynamic_cast<call2Fun*>($1);
																} |

         NUM         	                                        {
																	$$ = new retType();
																	retType* ret = dynamic_cast<retType*>($$);
																	Num* num = dynamic_cast<Num*>($1);
																	std::string reg = RegisterGenerator::getRegister();
																	ret->type = Type_::TYPE_INT ;
																	ret->reg = reg;
																	CodeGenerator::generateIntByteCreationCode(reg, num->value);
																	delete num;
																} |
         NUM B       	                                        {
																	$$ = new retType();
																	retType* ret = dynamic_cast<retType*>($$);
																	Num* num = dynamic_cast<Num*>($1);
																	if(std::stoi(num->value) >= 256) {
																		output::errorByteTooLarge(yylineno, num->value); 
																		exit(1);
																	}
																	std::string reg = RegisterGenerator::getRegister();
																	ret->type = Type_::TYPE_BYTE;
																	ret->reg = reg;
																	CodeGenerator::generateIntByteCreationCode(reg, num->value);
																	delete num;
																} |
         STRING      	                                        {
																	$$ = new retType();
																	retType* result = dynamic_cast<retType*>($$);
																	result->type = Type_::TYPE_STRING;
																	CodeGenerator::generateStringCode(result, dynamic_cast<String*>($1));
																	delete dynamic_cast<String*>($1);
																} |
		 
         TRUE        	                                        {
																	$$ = new retType();
																	retType* result = dynamic_cast<retType*>($$);
																	result->type = Type_::TYPE_BOOL ;
																	int lineOfCode = codeBuff.emit("br label @");
                                                                    result->trueList.push_back({lineOfCode, BranchLabelIndex::FIRST});
																} |
																
         FALSE       	                                        {
																	$$ = new retType(); 
																	retType* result = dynamic_cast<retType*>($$);
																	result->type = Type_::TYPE_BOOL ;
																	int lineOfCode = codeBuff.emit("br label @");
                                                                    result->falseList.push_back({lineOfCode, BranchLabelIndex::FIRST});
																} |
																
         NOT Exp     	                                        {
																	$$ = new retType(); 
																	retType* ret = dynamic_cast<retType*>($$);
																	retType* exp = dynamic_cast<retType*>($2);
																	CheckType(exp->type, Type_::TYPE_BOOL);
																	ret->type = Type_::TYPE_BOOL;
																	ret->trueList = exp->falseList;
																	ret->falseList = exp->trueList;
																	delete dynamic_cast<retType*>($2);
																} |
																
         Exp AND M_INSTR Exp 	                                {
																	$$ = new retType(); 
																	retType* result = dynamic_cast<retType*>($$);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($4);
																	CheckType(exp1->type, Type_::TYPE_BOOL);
																	CheckType(exp2->type, Type_::TYPE_BOOL);
																	result->type = Type_::TYPE_BOOL;
																	codeBuff.bpatch(exp1->trueList, dynamic_cast<Label*>($3)->label);
																	result->trueList = exp2->trueList;
																	result->falseList = codeBuff.merge(exp1->falseList, exp2->falseList);
																	delete exp1; 
																	delete exp2;
																} |
																
         Exp OR M_INSTR Exp		                                {
																	$$ = new retType();
																	retType* result = dynamic_cast<retType*>($$);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($4);
																	CheckType(exp1->type, Type_::TYPE_BOOL);
																	CheckType(exp2->type, Type_::TYPE_BOOL);
																	result->type = Type_::TYPE_BOOL;
																	codeBuff.bpatch(exp1->falseList, dynamic_cast<Label*>($3)->label);
																	result->falseList = exp2->falseList;
																	result->trueList = codeBuff.merge(exp1->trueList, exp2->trueList);
																	delete exp1;
																	delete exp2;
																} |
																
         Exp RELOP_EQ Exp                                 		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode = freshReg + " = icmp eq i32 " + exp1->reg + ", " + exp2->reg;
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} |
																
		Exp RELOP_NOTEQ Exp                                 	{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode = freshReg + " = icmp eq i32 " + exp1->reg + ", " + exp2->reg;
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} |
																
		 Exp RELOP_LESS Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ult i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp slt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_GREATER Exp                               	{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ugt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sgt i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_LEQ Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp ule i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sle i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
		Exp RELOP_GEQ Exp                               		{
																	$$ = new retType();
																	checkIfNumType(dynamic_cast<retType*>($1)->type);
																	checkIfNumType(dynamic_cast<retType*>($3)->type);
																	retType* exp1 = dynamic_cast<retType*>($1);
																	retType* exp2 = dynamic_cast<retType*>($3);
																	retType* result = dynamic_cast<retType*>($$);
																	dynamic_cast<retType*>($$)->type = Type_::TYPE_BOOL;
																	std::string freshReg = RegisterGenerator::getRegister();
																	std::string comparisonCode;
																	if(Type_::TYPE_BYTE == exp1->type && Type_::TYPE_BYTE == exp2->type)
																	{
																		comparisonCode = freshReg + " = icmp uge i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	else
																	{
																		comparisonCode = freshReg + " = icmp sge i32 " + exp1->reg + ", " + exp2->reg;
																	}
																	codeBuff.emit(comparisonCode);
																	std::string jumpCode = "br i1 "+ freshReg + ", label @, label @";
																	int lineOfCode = codeBuff.emit(jumpCode);
																	result->trueList = codeBuff.makelist({lineOfCode, BranchLabelIndex::FIRST});
                                                                    result->falseList = codeBuff.makelist({lineOfCode, BranchLabelIndex::SECOND});
																	delete exp1;
																	delete exp2;
																} | 
																
         LPAREN Type RPAREN Exp	                                {
																	$$ = new retType();
																	if(!(((dynamic_cast<retType*>($2)->type == Type_::TYPE_INT)  && (dynamic_cast<retType*>($4)->type == Type_::TYPE_BYTE))
																	||  ((dynamic_cast<retType*>($2)->type == Type_::TYPE_BYTE)  && (dynamic_cast<retType*>($4)->type == Type_::TYPE_INT))
																	|| ((dynamic_cast<retType*>($2)->type == dynamic_cast<retType*>($4)->type))))
																	{output::errorMismatch(yylineno);exit(1);}
																	dynamic_cast<retType*>($$)->type= dynamic_cast<retType*>($2)->type ;
																	delete dynamic_cast<retType*>($2); delete dynamic_cast<retType*>($4);
																}
	;
	
	CLOSE_SCOPE: {symbolTableManager.closeScope();};
	Bool_Exp: Exp 	{
						retType* exp = dynamic_cast<retType*>($1);
						CheckType(exp->type, Type_::TYPE_BOOL);
						if(exp->reg != "")
						{
							string truncReg = CodeGenerator::generateTruncRegisterCode(exp->reg);
							int branch_line = codeBuff.emit("br i1 " + truncReg + ", label @, label @");
							exp->trueList = codeBuff.makelist({branch_line, FIRST});
							exp->falseList = codeBuff.makelist({branch_line, SECOND});
						}
						$$ = $1;
						symbolTableManager.openScope();
					};
					
	M_INSTR : {$$ = new Label(codeBuff.genLabel());};
	
	M_JUMP: {
				$$ = new JumpMarker();
				JumpMarker* marker = dynamic_cast<JumpMarker*>($$);
				int line = codeBuff.emit("br label @");
				marker->nextList = codeBuff.makelist({line, FIRST});
			};

%%

int main()
{
    return yyparse();
}

void yyerror(const char* message)
{
    output::errorSyn(yylineno);
    exit(1);
}

void InsertPrintFunctions()
{
	std::shared_ptr<SymbolTable> globalScope = symbolTableManager.top();
	std::vector<Type_> printParams = std::vector<Type_>(1, Type_::TYPE_STRING);
	SymbolTableEntry entry = SymbolTableEntry("print", Type_::TYPE_VOID, 0, printParams); 
	globalScope->table.push_back(entry);
	
	std::vector<Type_> printIParams = std::vector<Type_>(1, Type_::TYPE_INT);
	entry = SymbolTableEntry("printi", Type_::TYPE_VOID, 0, printIParams);
	globalScope->table.push_back(entry);
}

void CheckType( Type_ target, Type_ given)
{
    if ((target == TYPE_INT && given == TYPE_BYTE))
    {
        return;
    }
    if (target != given)
    {
        output::errorMismatch(yylineno);
        exit(1);
    }
}

void checkIfVarExists(Type_ type, const std::string& name)
{
    if(symbolTableManager.doesSymbolExists(type, name))
    {
        output::errorDef(yylineno, name);
        exit(1);
    }
}

void MakeDeclaration(Type_ type, const std::string& name)
{
    checkIfVarExists(type, name);
    symbolTableManager.top()->Insert(name, type, symbolTableManager.getOffset());
}

void checkIfFuncExist(const std::string& name, std::vector<Type_> params)
{
    if (!symbolTableManager.isFunction(name)) // no matching name for func
    {
          output::errorUndefFunc(yylineno, name);
          exit(1);
    }
    if(symbolTableManager.doesFunctionExist(name, params) == Type_::TYPE_NOT_VALID) // no right params
    {
       std::vector<std::string> real_params = symbolTableManager.getParamList(name);
       output::errorPrototypeMismatch(yylineno, name, real_params);
       exit(1);
    }
}

void CheckIfAssignmentValid(const std::string& name, Type_ type2)
{
	Type_ type1 = symbolTableManager.getVarType(name);
	if(Type_::TYPE_NOT_VALID == type1)
	{
		output::errorUndef(yylineno, name);
		exit(1);
	}
	CheckType(type1,type2);
}

void checkIfNumType(Type_ type)
{
	if((type != Type_::TYPE_INT) && (type != Type_::TYPE_BYTE))
	{
		output::errorMismatch(yylineno);
        exit(1);
	}
}

void checkIfDoubleDeclare(const std::string& name, std::vector<std::string>names_in_list)
{
    for (auto it = names_in_list.begin(); it != names_in_list.end(); it++)
    {
        for (std::vector<std::string>::iterator it2 = it; it2 != names_in_list.end(); it2++)
        {
            if ((*it2 == *it) && (it != it2)) //same parameter name twice
            {
                  output::errorDef(yylineno, *it2);
                  exit(1);
            }
        }
    }
    for (auto it = names_in_list.begin(); it != names_in_list.end(); it++)
    {
        if (*it == name) //param is equal to func name
        {
            output::errorDef(yylineno, name);
            exit(1);
        }
    }
}

bool isRetTypeMismatch(Type_ expType)
{
	return (
			((symbolTableManager.getCurrentScopeFunctionReturnType() != expType) &&
			
			(expType != Type_::TYPE_BYTE || (symbolTableManager.getCurrentScopeFunctionReturnType() != Type_::TYPE_INT)))
			
			|| (Type_::TYPE_VOID == symbolTableManager.getCurrentScopeFunctionReturnType()));
}

void checkIfMainRedefined(const std::string& functionName)
{
	if(symbolTableManager.isFunction(functionName))
	{
		output::errorDef(yylineno, functionName);
		exit(1);
	}
}

void CheckIfValidTypeForVar(const Type_ type_to_assign)
{
	if(TYPE_VOID == type_to_assign || TYPE_STRING == type_to_assign || TYPE_NOT_VALID == type_to_assign)
	{
		output::errorMismatch(yylineno);
		exit(1);
	}
}

void debug()
{
	cerr << "debug" << endl;
}


